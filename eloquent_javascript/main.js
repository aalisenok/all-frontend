// ========== CHAPTER 0: Introduction ========== //
// ========== CHAPTER 1: Values, Types and Operators  ========== //
// ========== CHAPTER 2: Program Structure ========== //

// ++++++++++ TASK 01 - START ++++++++++ //
// Треугольник в цикле
// Напишите цикл, который за 7 вызовов console.log выводит такой треугольник:
// #
// ##
// ###
// ####
// #####
// ######
// #######

// for (let line = '#'; line.length < 8; line += "#") {
//     console.log(line);
// }

// ++++++++++ TASK 01 - END ++++++++++ //

// ++++++++++ TASK 02 - START ++++++++++ //
// FizzBuzz
// Напишите программу, которая выводит через console.log все числа от 1 до 100, с двумя исключениями.
// Для чисел, нацело делящихся на 3, она должна выводить ‘Fizz’, а для чисел, делящихся на 5 (но не на 3) – ‘Buzz’.
// Когда сумеете – исправьте её так, чтобы она выводила «FizzBuzz» для всех чисел, которые делятся и на 3, и на 5.
// (На самом деле, этот вопрос подходит для собеседований, и, говорят, он позволяет отсеивать довольно большое число кандидатов.
// Поэтому, когда вы решите эту задачу, можете себя похвалить.)

// for (let num = 1; num < 101 ; num++) {
//     let output = '';
//     if (num % 3 === 0) output += 'Fizz';
//     if (num % 5 === 0) output += 'Buzz';
//     console.log(output || num);
// }

// ++++++++++ TASK 02 - END ++++++++++ //

// ++++++++++ TASK 03 - START ++++++++++ //
// Шахматная доска
// Напишите программу, создающую строку, содержащую решётку 8х8, в которой линии разделяются символами новой строки.
// На каждой позиции либо пробел, либо #. В результате должна получиться шахматная доска.

// let size = 8;
// let board = '';
// for (let i = 0; i < size; i++) {
//     for (let j =0; j < size; j++) {
//         if ((i + j) % 2 === 0) {
//             board += ' ';
//         } else board += '#';
//     }
//     board += '\n';
// }
// console.log(board);

// ++++++++++ TASK 03 - END ++++++++++ //

// ========== CHAPTER 3: Functions ========== //

// ++++++++++ TASK 04 - START ++++++++++ //
// В предыдущей главе была упомянута функция Math.min, возвращающая самый маленький из аргументов.
// Теперь мы можем написать такую функцию сами.
// Напишите функцию min, принимающую два аргумента, и возвращающую минимальный из них.

// function min(a, b) {
//     if (a < b) return a;
//     else return b;
// }
// console.log(min(0, 10));
// → 0
// console.log(min(0, -10));
// → -10
// ++++++++++ TASK 04 - END ++++++++++ //

// ++++++++++ TASK 05 - START ++++++++++ //
// Рекурсия
// Мы видели, что оператор % (остаток от деления) может использоваться для определения того, чётное ли число ( % 2).
// А вот ещё один способ определения:
// Ноль чётный.
// Единица нечётная.
// У любого числа N чётность такая же, как у N - 2.
// Напишите рекурсивную функцию isEven согласно этим правилам. Она должна принимать число и возвращать булевское значение.
// Потестируйте её на 50 и 75. Попробуйте задать ей -1. Почему она ведёт себя таким образом? Можно ли её как-то исправить?

// function isEven(n) {
//     if (n === 0) return true;
//     else if (n === 1) return false;
//     else if (n < 0) return isEven(-n);
//     else return isEven(n - 2);
// }
//
// console.log(isEven(50));
// → true
// console.log(isEven(75));
// → false
// console.log(isEven(-1));
// → false

// ++++++++++ TASK 05 - END ++++++++++ //

// ++++++++++ TASK 06 - START ++++++++++ //
// Считаем бобы
// Символ номер N строки можно получить, добавив к ней .charAt(N) ( "строчка".charAt(5) ) – схожим образом с получением длины строки при помощи .length.
// Возвращаемое значение будет строковым, состоящим из одного символа (к примеру, "к").
// У первого символа строки позиция 0, что означает, что у последнего символа позиция будет string.length - 1.
// Другими словами, у строки из двух символов длина 2, а позиции её символов будут 0 и 1.
// Напишите функцию countBs, которая принимает строку в качестве аргумента, и возвращает количество символов “B”, содержащихся в строке.
// Затем напишите функцию countChar, которая работает примерно как countBs, только принимает второй параметр — символ,
// который мы будем искать в строке (вместо того, чтобы просто считать количество символов “B”). Для этого переделайте функцию countBs.

// function countChar(string, ch) {
//     let counted = 0;
//     for (let i = 0; i < string.length; i++) {
//         if (string[i].toLocaleLowerCase() === ch.toLocaleLowerCase()) {
//             counted += 1;
//         }
//     }
//     return counted;
// }
//
// function countBs(string) {
//     return countChar(string, "B");
// }

// console.log(countBs("BBC"));
// → 2
// console.log(countChar("kakkeKKrlak", "k"));
// → 4

// ++++++++++ TASK 06 - END ++++++++++ //